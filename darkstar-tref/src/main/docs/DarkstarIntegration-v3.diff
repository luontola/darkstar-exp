Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java	(.../branches/decoupled/distro)	(revision 26)
@@ -24,6 +24,7 @@
 
 import com.sun.sgs.impl.service.transaction.TransactionCoordinator;
 import com.sun.sgs.impl.service.transaction.TransactionHandle;
+import com.sun.sgs.impl.service.data.DataServiceImpl;
 
 import com.sun.sgs.impl.sharedutil.LoggerWrapper;
 
@@ -224,6 +225,7 @@
         try {
 	    try {
 		task.run();
+		DataServiceImpl.notifyCurrentTransactionWillBeCleared();
 	    } finally {
 		// regardless of the outcome, always clear the current state
 		// before aborting or committing
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java	(.../branches/decoupled/distro)	(revision 26)
@@ -20,10 +20,8 @@
 package com.sun.sgs.impl.service.data;
 
 import com.sun.sgs.app.ManagedObject;
-import java.util.IdentityHashMap;
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.TreeMap;
+
+import java.util.*;
 import java.util.Map.Entry;
 
 /**
@@ -32,6 +30,10 @@
  */
 final class ReferenceTable {
 
+    private enum State {
+	ACTIVE, FLUSHING, CLOSED
+    }
+    
     /** Maps object IDs to managed references. */
     private final SortedMap<Long, ManagedReferenceImpl> oids =
 	new TreeMap<Long, ManagedReferenceImpl>();
@@ -43,6 +45,11 @@
     private final Map<ManagedObject, ManagedReferenceImpl> objects =
 	new IdentityHashMap<ManagedObject, ManagedReferenceImpl>();
 
+    private State state = State.ACTIVE;
+    private final List<ManagedReferenceImpl> flushQueue = new ArrayList<ManagedReferenceImpl>();
+    private final Collection<ManagedObject> unregisterAfterFlush = new ArrayList<ManagedObject>();
+    private FlushInfo flushed;
+
     /** Creates an instance of this class. */
     ReferenceTable() { }
 
@@ -66,6 +73,10 @@
 
     /** Adds a new managed reference to this table. */
     void add(ManagedReferenceImpl ref) {
+	assert state != State.CLOSED;
+	if (state == State.FLUSHING) {
+	    flushQueue.add(ref);
+	}
 	assert !oids.containsKey(ref.oid)
 	    : "Found existing reference for oid:" + ref.oid;
 	oids.put(ref.oid, ref);
@@ -96,7 +107,11 @@
      */
     void unregisterObject(ManagedObject object) {
 	assert objects.containsKey(object) : "Object was not found";
-	objects.remove(object);
+        if (state == State.FLUSHING) {
+            unregisterAfterFlush.add(object);
+        } else {
+            objects.remove(object);
+        }
     }
 
     /** Removes a managed reference from this table. */
@@ -133,20 +148,51 @@
      * Flushes all references.  Returns information about any objects found to
      * be modified, or null if none were modified.
      */
+    @SuppressWarnings({"ForLoopReplaceableByForEach"})
     FlushInfo flushModifiedObjects() {
-	FlushInfo flushInfo = null;
-	for (ManagedReferenceImpl ref : oids.values()) {
-	    byte[] data = ref.flush();
-	    if (data != null) {
-		if (flushInfo == null) {
-		    flushInfo = new FlushInfo();
+	if (state == State.CLOSED) {
+	    return flushed;
+	}
+	try {
+	    beginFlush();
+	    FlushInfo flushInfo = null;
+	    // ref.flush() may add more elements to flushQueue, so we must use indexing
+	    // instead of foreach (uses Iterator) to avoid ConcurrentModificationException
+	    for (int i = 0; i < flushQueue.size(); i++) {
+		ManagedReferenceImpl ref = flushQueue.get(i);
+		byte[] data = ref.flush();
+		if (data != null) {
+		    if (flushInfo == null) {
+			flushInfo = new FlushInfo();
+		    }
+		    flushInfo.add(ref.oid, data);
 		}
-		flushInfo.add(ref.oid, data);
 	    }
+	    flushed = flushInfo;
+	    return flushInfo;
+	} finally {
+	    endFlush();
 	}
-	return flushInfo;
     }
 
+    private void beginFlush() {
+	assert state == State.ACTIVE;
+	assert flushQueue.isEmpty();
+	assert unregisterAfterFlush.isEmpty();
+	state = State.FLUSHING;
+	flushQueue.addAll(oids.values());
+    }
+
+    private void endFlush() {
+	assert state == State.FLUSHING;
+	state = State.CLOSED;
+	flushQueue.clear();
+	for (ManagedObject object : unregisterAfterFlush) {
+	    unregisterObject(object);
+	}
+	unregisterAfterFlush.clear();
+    }
+
     /**
      * Checks the consistency of this table, throwing an assertion error if a
      * problem is found.
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/DataServiceImpl.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/DataServiceImpl.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/DataServiceImpl.java	(.../branches/decoupled/distro)	(revision 26)
@@ -754,6 +754,22 @@
 	}
     }
 
+    /**
+     * Warns the data service that {@link com.sun.sgs.impl.kernel.ThreadState#clearCurrentTransaction} will be 
+     * called soon, and the data service should flush all ManagedReferences while the transaction is still active.
+     */
+    public static void notifyCurrentTransactionWillBeCleared() {
+	Context context = null;
+	try {
+	    context = getContextNoJoin();
+	} catch (Exception e) {
+	    // no context active, no need to flush
+	}
+	if (context != null) {
+	    ManagedReferenceImpl.prepareForFlushAll(context);
+	}
+    }
+
     /* -- Implement ProfileProducer -- */
 
     /**
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ManagedReferenceImpl.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ManagedReferenceImpl.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ManagedReferenceImpl.java	(.../branches/decoupled/distro)	(revision 26)
@@ -501,6 +501,15 @@
 	}
     }
 
+    /**
+     * Must be called before {@link com.sun.sgs.impl.kernel.ThreadState#clearCurrentTransaction}.
+     * It won't be possible to create transparent references during flushing
+     * if there is no current transaction.
+     */
+    static void prepareForFlushAll(Context context) {
+	context.refs.flushModifiedObjects();
+    }
+
     /** Saves all object modifications to the data store. */
     static void flushAll(Context context) {
 	FlushInfo info = context.refs.flushModifiedObjects();
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java	(.../branches/decoupled/distro)	(revision 26)
@@ -23,14 +23,11 @@
 import com.sun.sgs.app.ManagedReference;
 import com.sun.sgs.app.ObjectIOException;
 import com.sun.sgs.impl.sharedutil.LoggerWrapper;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamClass;
-import java.io.OutputStream;
+import net.orfjackal.sgs.TransparentReferenceFactory;
+import net.orfjackal.sgs.TransparentReferenceUtil;
+import net.orfjackal.sgs.TransparentReferenceImpl;
+
+import java.io.*;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -291,10 +288,8 @@
 	/** Check for references to managed objects. */
 	protected Object replaceObject(Object object) throws IOException {
 	    if (object != topLevelObject && object instanceof ManagedObject) {
-		throw new ObjectIOException(
-		    "ManagedObject was not referenced through a " +
-		    "ManagedReference: " + safeToString(object),
-		    false);
+		TransparentReferenceFactory factory = TransparentReferenceImpl.getFactory();
+		return TransparentReferenceUtil.createTransparentReferenceForSerialization((ManagedObject) object, factory);
 	    } else if (object != null) {
 		Class<?> cl = object.getClass();
 		if (cl.isAnonymousClass()) {
