Index: ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java
===================================================================
--- ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java	(revision 14)
+++ ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java	Mon Jan 28 17:16:31 EET 2008
@@ -23,14 +23,11 @@
 import com.sun.sgs.app.ManagedReference;
 import com.sun.sgs.app.ObjectIOException;
 import com.sun.sgs.impl.sharedutil.LoggerWrapper;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamClass;
-import java.io.OutputStream;
+import net.orfjackal.sgs.TransparentReferenceCglibProxyFactory;
+import net.orfjackal.sgs.TransparentReferenceFactory;
+import net.orfjackal.sgs.TransparentReferenceUtil;
+
+import java.io.*;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -253,7 +250,7 @@
 	{
 	    classSerial.writeClassDescriptor(desc, this);
 	}
-    }	
+    }
 
     /**
      * Define an ObjectOutputStream that checks for references to
@@ -291,10 +288,8 @@
 	/** Check for references to managed objects. */
 	protected Object replaceObject(Object object) throws IOException {
 	    if (object != topLevelObject && object instanceof ManagedObject) {
-		throw new ObjectIOException(
-		    "ManagedObject was not referenced through a " +
-		    "ManagedReference: " + safeToString(object),
-		    false);
+                TransparentReferenceFactory factory = TransparentReferenceCglibProxyFactory.INSTANCE;
+                return TransparentReferenceUtil.createTransparentReferenceForSerialization((ManagedObject) object, factory);
 	    } else if (object != null) {
 		Class<?> cl = object.getClass();
 		if (cl.isAnonymousClass()) {
Index: ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java
===================================================================
--- ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java	(revision 14)
+++ ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java	Mon Jan 28 16:51:19 EET 2008
@@ -21,17 +21,12 @@
 
 import com.sun.sgs.app.ExceptionRetryStatus;
 import com.sun.sgs.app.TransactionNotActiveException;
-
 import com.sun.sgs.impl.service.transaction.TransactionCoordinator;
 import com.sun.sgs.impl.service.transaction.TransactionHandle;
-
 import com.sun.sgs.impl.sharedutil.LoggerWrapper;
-
 import com.sun.sgs.kernel.KernelRunnable;
 import com.sun.sgs.kernel.TaskOwner;
-
 import com.sun.sgs.profile.ProfileCollector;
-
 import com.sun.sgs.service.Transaction;
 
 import java.util.logging.Level;
@@ -224,6 +219,7 @@
         try {
 	    try {
 		task.run();
+                handle.commit();
 	    } finally {
 		// regardless of the outcome, always clear the current state
 		// before aborting or committing
@@ -231,7 +227,7 @@
 	    }
 	    // commit the transaction, allowing any exceptions to be thrown,
 	    // since they will indicate whether this task is re-tried
-	    handle.commit();
+//	    handle.commit();
 	    return;
 	} catch (Exception e) {
 	    throwable = e;
Index: ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java
===================================================================
--- ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java	(revision 14)
+++ ../distro/sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java	Mon Jan 28 17:18:35 EET 2008
@@ -20,10 +20,8 @@
 package com.sun.sgs.impl.service.data;
 
 import com.sun.sgs.app.ManagedObject;
-import java.util.IdentityHashMap;
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.TreeMap;
+
+import java.util.*;
 import java.util.Map.Entry;
 
 /**
@@ -43,6 +41,10 @@
     private final Map<ManagedObject, ManagedReferenceImpl> objects =
 	new IdentityHashMap<ManagedObject, ManagedReferenceImpl>();
 
+    private boolean flushing = false;
+    private final List<ManagedReferenceImpl> flushQueue = new ArrayList<ManagedReferenceImpl>();
+    private final Collection<ManagedObject> unregisterAfterFlush = new ArrayList<ManagedObject>();
+
     /** Creates an instance of this class. */
     ReferenceTable() { }
 
@@ -66,6 +68,9 @@
 
     /** Adds a new managed reference to this table. */
     void add(ManagedReferenceImpl ref) {
+        if (flushing) {
+            flushQueue.add(ref);
+        }
 	assert !oids.containsKey(ref.oid)
 	    : "Found existing reference for oid:" + ref.oid;
 	oids.put(ref.oid, ref);
@@ -96,8 +101,12 @@
      */
     void unregisterObject(ManagedObject object) {
 	assert objects.containsKey(object) : "Object was not found";
+        if (flushing) {
+            unregisterAfterFlush.add(object);
+        } else {
-	objects.remove(object);
-    }
+            objects.remove(object);
+        }
+    }
 
     /** Removes a managed reference from this table. */
     void remove(ManagedReferenceImpl ref) {
@@ -133,20 +142,46 @@
      * Flushes all references.  Returns information about any objects found to
      * be modified, or null if none were modified.
      */
+    @SuppressWarnings({"ForLoopReplaceableByForEach"})
     FlushInfo flushModifiedObjects() {
+        try {
+            beginFlush();
-	FlushInfo flushInfo = null;
+            FlushInfo flushInfo = null;
-	for (ManagedReferenceImpl ref : oids.values()) {
+            // ref.flush() may add more elements to flushQueue, so we must use indexing
+            // instead of foreach (uses Iterator) to avoid ConcurrentModificationException
+            for (int i = 0; i < flushQueue.size(); i++) {
+                ManagedReferenceImpl ref = flushQueue.get(i);
-	    byte[] data = ref.flush();
-	    if (data != null) {
-		if (flushInfo == null) {
-		    flushInfo = new FlushInfo();
-		}
-		flushInfo.add(ref.oid, data);
-	    }
-	}
-	return flushInfo;
+                byte[] data = ref.flush();
+                if (data != null) {
+                    if (flushInfo == null) {
+                        flushInfo = new FlushInfo();
+                    }
+                    flushInfo.add(ref.oid, data);
+                }
+            }
+            return flushInfo;
+        } finally {
+            endFlush();
-    }
+        }
+    }
 
+    private void beginFlush() {
+        assert !flushing;
+        assert flushQueue.isEmpty();
+        assert unregisterAfterFlush.isEmpty();
+        flushing = true;
+        flushQueue.addAll(oids.values());
+    }
+
+    private void endFlush() {
+        flushing = false;
+        flushQueue.clear();
+        for (ManagedObject object : unregisterAfterFlush) {
+            unregisterObject(object);
+        }
+        unregisterAfterFlush.clear();
+    }
+
     /**
      * Checks the consistency of this table, throwing an assertion error if a
      * problem is found.
