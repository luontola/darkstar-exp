
	PROJECT DARKSTAR DECOUPLED

Mahdollistetaan Darkstarin (DS) käyttäminen ilman, että koodissa on riippuvuuksia DS:n arkkitehtuuriin (loose coupling, less invasive). Erityisesti ManagedObjectien (MO) yhteydessä käytettyjä ManagedReferencejä (MR) ei esiinny koodissa, vaan DS huolehtii niistä automaattisesti.


Keskeiset ideat:

- MO:hon viitataan aina rajapinnan kautta. Mahdollistaa olion korvaamisen MR-tyyppisellä proxyllä. Koodi on täten riippuvainen vain pelidomainin rajapintaan.

- Kustomoitu serialisointi: Kun olio serialisoidaan, niin DS korvaa instanssikentissä olevat MO:t MR-proxyillä. Ennen serialisointia MO:t voivat olla MR:n päässä tai ilman. Serialisoinnin jälkeen ne ovat aina MR:n päässä, kuten DS vaatii.


Serialisoinnin toteuttamisen vaihtoehtoja:

- Puukotetaan Javan oletusserialisointia, jos mahdollista. MO:t serialisoidaan olioverkon osana silloin, kun MO ei ole verkon juurisolmu. Muulloin MO:t korvataan vastaavalla MR:llä. Ehkä on mahdollista käyttää omaa versiota ObjectOutputStream:stä.
	java.io.ObjectOutputStream#writeObjectOverride
	++ java.io.ObjectOutputStream#replaceObject
	++ java.io.ObjectOutputStream#writeObject0
	+ java.io.ObjectOutputStream#writeOrdinaryObject
	+ java.io.ObjectOutputStream#defaultWriteFields

- DS käy olioverkon läpi ja korvaa MO:t MR:llä ennen kuin oliot serialisoidaan. Puukotuskohtia:
	com.sun.sgs.impl.service.data.ManagedReferenceImpl#flushAll
	com.sun.sgs.impl.service.data.ReferenceTable#flushModifiedObjects
	+ com.sun.sgs.impl.service.data.ManagedReferenceImpl#flush
	++ com.sun.sgs.impl.service.data.SerialUtil#serialize
	++ com.sun.sgs.impl.service.data.SerialUtil.CheckReferencesObjectOutputStream
		* käy läpi olion kentät ja korvaa MO:t MR:llä
	com.sun.sgs.impl.service.data.store.DataStore#setObject
	com.sun.sgs.impl.service.data.store.DataStore#setObjects
	

- Serialisoitavien domain-luokkien (ei ainoastaan MO-luokkien) writeObject-metodissa kutsutaan apuluokkaa käymään läpi kyseisen olion instanssikentät ja korvaamaan MO:t MR:llä. Tämä on vaihtoehdoista huonoin, koska siitä tulee duplikoitua koodia jokaiseen domain-luokkaan.




JAVA SERIALIZATION

http://java.sun.com/javase/6/docs/platform/serialization/spec/output.html
http://java.sun.com/javase/6/docs/api/java/io/ObjectOutputStream.html

Google: java custom serialization
http://www.unix.org.ua/orelly/java/javanut/ch09_02.htm
http://www.themidnightcoders.com/doc20/invocation/serialization/serializers/custom.htm
http://www.precisejava.com/javaperf/j2se/Serialization.htm
http://mindprod.com/jgloss/serialization.html
http://livedocs.adobe.com/flex/201/html/wwhelp/wwhimpl/common/html/wwhelp.htm?context=LiveDocs_Book_Parts&file=ent_services_config_097_11.html


PROXYING

Google: jdk proxy

Dynamic Proxy Classes
http://java.sun.com/javase/6/docs/technotes/guides/reflection/proxy.html
http://java.sun.com/javase/6/docs/api/java/lang/reflect/Proxy.html

Why do you think CGLib proxies are faster than JDK Proxies?
http://www.theserverside.com/news/thread.tss?thread_id=45089

	>> Cglib is definitely faster
	>> Posted by: Bob Lee on April 23, 2007
	"If you're concerned about performance, whether you're using cglib or dynamic proxies, you should hold onto the proxy class and use that to create proxies instead. See the cglib-based method interception code in Guice for an example. http://google-guice.googlecode.com/svn/trunk/src/com/google/inject/ProxyFactory.java
	
	What matters is that cglib is faster for method interception. You only get one handler per object with dynamic proxies, which means you typically have to do at least one map lookup per method invocation. Cglib, on the other hand, lets you use separate handler for each method. This means no map lookups, and if you're not actually intercepting a method, no unnecessary overhead."



>> Viesti DS:n foorumeille 23.1.2008
>> http://www.projectdarkstar.com/index.php?option=com_smf&Itemid=44&topic=329.0

I've been reading Darkstar's documentation (implementing a game with it is still in the distant future) and it looks like a promising system. However, the tight coupling between the game code and Darkstar disturbs me (have a look at Spring for an example of a framework supporting loose coupling).

The biggest problem is that ManagedReferences need to be managed manually, even though it is an implementation detail of the framework (related to data storage and multithreading). The code which uses Darkstar should not need to know about those details. I've noticed that here at the forums there has been some discussion related to generics support for ManagedReferences [url=http://www.projectdarkstar.com/index.php?option=com_smf&Itemid=44&topic=281.0][1][/url][url=http://www.projectdarkstar.com/index.php?option=com_smf&Itemid=44&topic=57.0][2][/url], but today I had an idea how to hide the ManagedReferences completely from application code (more about this later).

The second coupling issue is how all managers are retrieved through a global AppContext class. The managers could be provided through dependency injection. But since it appers that you already have some support for unit testing and mocking managers, this coupling is not a big problem. Dependency injection would propably not be worth the effort.

The third one is how you need to manually mark the ManagedObjects modified. It would be nice to have it done automatically, but I understand that because of performance and other reasons it would be hard. I suppose that with a good architecture the trouble of having to call markForUpdate can be minimized. (What is the recommended way to do it - should each ManagedObject be responsible for marking itself for modifications?)

Then onto the idea I mentioned earlier...


[size=14pt]Transparent references[/size]

It is possible that the domain code will have no dependency to the ManagedReference class. There are two prerequisites to this:

- All ManagedObjects are referenced in domain code only through the interfaces that they implement (using interfaces is in any case a good habbit). The interfaces should not extend ManagedObject. Specifically, there should be no instance fields whose declared type implements ManagedObject.

- Darkstar's serialization mechanism is modified as I will describe below.

The result is that Darkstar will automagically create ManagedReferences for all ManagedObjects before they are serialized. The ManagedObject instances are replaced with a proxy, which contains a ManagedReference to the real ManagedObject. The proxy implements the same interfaces as the ManagedObject (excluding the ManagedObject interface), so the proxy can be used interchangeably with the real ManagedObject.

Some side effects are that the caller of the object will not be able to use getForUpdate, markForUpdate nor removeObject. The question is, should anyone other than the ManagedObject itself use them? (If in some special case a direct reference to the ManagedObject instance is required, I've provided helper methods for it in my code. However, in most cases, I don't think that they will be needed.)


[size=14pt]Implementation[/size]

I've attached TransparentReferencer.java which contains the code for automatically creating ManagedReferences. I've also provided SerialUtil.patch for integrating it to Darkstar. All that is needed is adding one line to the com.sun.sgs.impl.service.data.SerialUtil.CheckReferencesObjectOutputStream#replaceObject method and lots of testing (I haven't tried running any of the code, because I'm not yet making a Darkstar game).

You could also add a switch for enabling/disabling the creating of transparent references, in case it causes problems for somebody. Some performance benchmarks would also be nice, to make sure that there is no significant overhead in creating and using the transparent references.

The program uses JDK proxying for creating the transparent reference proxies.

The TransparentReferencer does not yet support arrays, and collections support has not been tested. Those collections which do not use arrays might already work. Implementing array support should be quite straightforward.

There might be a problem if a ManagedObject implementation is changed so that it implements more interfaces. Any serialized proxies are not updated, so the code might break at runtime if somebody tries to cast the proxy to one of the newly implemented interfaces. Avoiding this would require checking the proxy whenever it is unserialized, to make sure that it implements the same interfaces as the ManagedObject whose proxy it is. If there is need for this checking, but it causes a performance problem, having a switch for enabling/disabling the checking would be good.


Feedback is welcome. :)


>> 30.1.2008

EQUALS() JA HASHCODE() -ONGELMA

Seuraavien kolmen asian pitäisi olla ekvivalentteja:

- ManagedObject X
- ManagedReference to ManagedObject X
- TransparentReference wrapping ManagedReference to ManagedObject X

Viitteiden equals() ja hashCode() -metodi on mahdollista muuttaa huomioimaan kaikki vaihtoehdot. Ne on toteutettava siten, että kun ManagedReference on EMPTY, niin oliota ei noudeta kannasta. Ei siksi ole kätevää käyttää sellaista proxyä, joka delegoi kyseiset kutsut ManagedObjectille.

Mutta Object:n oletustoteutus ei toimi samalla logiikalla, kun kutsutaan ManagedObject.equals(TransparentReference). Pitänee vaatia, että ManagedObjectit toteuttavat metodit näin:

public boolean equals(Object other) {
	return ManagedIdentity.equals(this, other);
}

public int hashCode() {
	return ManagedIdentity.hashCode(this);
}

Apumetodi huomioi kaikki olio ja viite -kombinaatiot (ehkä käyttäen http://en.wikipedia.org/wiki/Double_dispatch).

