Index: sgs-src-0.9.5-r3615/test/server/j2se/com/sun/sgs/test/impl/service/transaction/TestTransactionCoordinatorImpl.java
===================================================================
--- sgs-src-0.9.5-r3615/test/server/j2se/com/sun/sgs/test/impl/service/transaction/TestTransactionCoordinatorImpl.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/test/server/j2se/com/sun/sgs/test/impl/service/transaction/TestTransactionCoordinatorImpl.java	(.../branches/decoupled/distro)	(revision 23)
@@ -126,6 +126,7 @@
 	for (TransactionParticipant participant : participants) {
 	    txn.join(participant);
 	}
+	handle.prepare();
 	handle.commit();
 	for (DummyTransactionParticipant participant : participants) {
 	    if (!participant.prepareReturnedTrue()) {
@@ -136,6 +137,7 @@
     }
 
     public void testCommitActiveEmpty() throws Exception {
+	handle.prepare();
 	handle.commit();
 	assertCommitted();
     }
@@ -149,6 +151,7 @@
 	    new DummyNonDurableTransactionParticipant() {
 		public void abort(Transaction txn) {
 		    try {
+			handle.prepare();
 			handle.commit();
 			fail("Expected IllegalStateException");
 		    } catch (IllegalStateException e) {
@@ -181,6 +184,7 @@
 	txn.join(new DummyTransactionParticipant());
 	txn.abort(null);
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionNotActiveException");
 	} catch (TransactionNotActiveException e) {
@@ -198,6 +202,7 @@
 	    new DummyNonDurableTransactionParticipant() {
 		public boolean prepare(Transaction txn) {
 		    try {
+			handle.prepare();
 			handle.commit();
 			fail("Expected IllegalStateException");
 		    } catch (IllegalStateException e) {
@@ -219,6 +224,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IllegalStateException");
 	} catch (IllegalStateException e) {
@@ -242,6 +248,7 @@
 	    new DummyTransactionParticipant() {
 		public void prepareAndCommit(Transaction txn) {
 		    try {
+			handle.prepare();
 			handle.commit();
 			fail("Expected IllegalStateException");
 		    } catch (IllegalStateException e) {
@@ -258,6 +265,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IllegalStateException");
 	} catch (IllegalStateException e) {
@@ -280,6 +288,7 @@
 	    new DummyNonDurableTransactionParticipant() {
 		public void commit(Transaction txn) {
 		    try {
+			handle.prepare();
 			handle.commit();
 			fail("Expected IllegalStateException");
 		    } catch (IllegalStateException e) {
@@ -297,6 +306,7 @@
 	for (TransactionParticipant participant : participants) {
 	    txn.join(participant);
 	}
+	handle.prepare();
 	handle.commit();
 	for (DummyTransactionParticipant participant : participants) {
 	    if (!participant.prepareReturnedTrue()) {
@@ -310,8 +320,10 @@
 
     public void testCommitCommitted() throws Exception {
 	txn.join(new DummyTransactionParticipant());
+	handle.prepare();
 	handle.commit();
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IllegalStateException");
 	} catch (IllegalStateException e) {
@@ -341,6 +353,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IOException");
 	} catch (IOException e) {
@@ -373,6 +386,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IOException");
 	} catch (IOException e) {
@@ -411,6 +425,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionAbortedException");
 	} catch (TransactionAbortedException e) {
@@ -444,6 +459,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionAbortedException");
 	} catch (TransactionAbortedException e) {
@@ -482,6 +498,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IOException");
 	} catch (IOException e) {
@@ -518,6 +535,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IOException");
 	} catch (IOException e) {
@@ -551,6 +569,7 @@
 	for (TransactionParticipant participant : participants) {
 	    txn.join(participant);
 	}
+	handle.prepare();
 	handle.commit();
 	for (DummyTransactionParticipant participant : participants) {
 	    if (!participant.prepareReturnedTrue()) {
@@ -567,6 +586,7 @@
 	Exception abortCause = new TransactionAbortedException("Aborted");
 	txn.abort(abortCause);
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionNotActiveException");
 	} catch (TransactionNotActiveException e) {
@@ -581,6 +601,7 @@
 	Exception abortCause = new IllegalArgumentException();
 	txn.abort(abortCause);
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionNotActiveException");
 	} catch (TransactionNotActiveException e) {
@@ -594,6 +615,7 @@
     public void testCommitAbortedWithNoCause() throws Exception {
 	txn.abort(null);
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionNotActiveException");
 	} catch (TransactionNotActiveException e) {
@@ -646,11 +668,13 @@
 		}
 	    };
 	txn.join(participant);
+	handle.prepare();
 	handle.commit();
     }
 
     public void testGetTransactionCommitted() throws Exception {
 	txn.join(new DummyTransactionParticipant());
+	handle.prepare();
 	handle.commit();
 	handle.getTransaction();
     }
@@ -792,6 +816,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IllegalStateException");
 	} catch (IllegalStateException e) {
@@ -831,6 +856,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected IllegalStateException");
 	} catch (IllegalStateException e) {
@@ -870,6 +896,7 @@
 	for (TransactionParticipant participant : participants) {
 	    txn.join(participant);
 	}
+	handle.prepare();
 	handle.commit();
 	for (DummyTransactionParticipant participant : participants) {
 	    if (!participant.prepareReturnedTrue()) {
@@ -882,6 +909,7 @@
     }
 
     public void testJoinCommitted() throws Exception {
+	handle.prepare();
 	handle.commit();
 	DummyTransactionParticipant participant =
 	    new DummyTransactionParticipant();
@@ -986,6 +1014,7 @@
 	assertAborted(abortCause);
 	handle.getTransaction();
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionNotActiveException");
 	} catch (TransactionNotActiveException e) {
@@ -1088,6 +1117,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionAbortedException");
 	} catch (TransactionAbortedException e) {
@@ -1122,6 +1152,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionAbortedException");
 	} catch (TransactionAbortedException e) {
@@ -1174,6 +1205,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionAbortedException");
 	} catch (TransactionAbortedException e) {
@@ -1209,6 +1241,7 @@
 	    txn.join(participant);
 	}
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionAbortedException");
 	} catch (TransactionAbortedException e) {
@@ -1250,6 +1283,7 @@
 	for (TransactionParticipant participant : participants) {
 	    txn.join(participant);
 	}
+	handle.prepare();
 	handle.commit();
 	for (DummyTransactionParticipant participant : participants) {
 	    if (!participant.prepareReturnedTrue()) {
@@ -1263,6 +1297,7 @@
 
     public void testAbortCommitted() throws Exception {
 	txn.join(new DummyTransactionParticipant());
+	handle.prepare();
 	handle.commit();
 	assertCommitted();
 	try {
@@ -1432,6 +1467,7 @@
 	for (DummyTransactionParticipant participant : participants) {
 	    txn.join(participant);
 	}
+	handle.prepare();
 	handle.commit();
 	assertNull(checkTimeoutException[0]);
     }
@@ -1457,6 +1493,7 @@
 	}
 	Thread.sleep(TIMED_OUT);
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionTimeoutException");
 	} catch (TransactionTimeoutException e) {
@@ -1479,6 +1516,7 @@
 		}
 	    };
 	txn.join(participant);
+	handle.prepare();
 	handle.commit();
 	assertNull(checkTimeoutException[0]);
     }
@@ -1501,6 +1539,7 @@
 	txn.join(participant);
 	Thread.sleep(TIMED_OUT);
 	try {
+	    handle.prepare();
 	    handle.commit();
 	    fail("Expected TransactionTimeoutException");
 	} catch (TransactionTimeoutException e) {
@@ -1523,6 +1562,7 @@
 		}
 	    };
 	txn.join(participant);
+	handle.prepare();
 	handle.commit();
 	assertNull(checkTimeoutException[0]);
     }
@@ -1542,11 +1582,13 @@
 	    };
 	txn.join(participant);
 	Thread.sleep(TIMED_OUT);
+	handle.prepare();
 	handle.commit();
 	assertNull(checkTimeoutException[0]);
     }
 
     public void testCheckTimeoutCommitted() throws Exception {
+	handle.prepare();
 	handle.commit();
 	try {
 	    txn.checkTimeout();
@@ -1557,6 +1599,7 @@
 	handle = coordinator.createTransaction(false);
 	txn = handle.getTransaction();
 	Thread.sleep(TIMED_OUT);
+	handle.prepare();
 	handle.commit();
 	try {
 	    txn.checkTimeout();
Index: sgs-src-0.9.5-r3615/test/server/j2se/com/sun/sgs/impl/kernel/MinimalTestKernel.java
===================================================================
--- sgs-src-0.9.5-r3615/test/server/j2se/com/sun/sgs/impl/kernel/MinimalTestKernel.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/test/server/j2se/com/sun/sgs/impl/kernel/MinimalTestKernel.java	(.../branches/decoupled/distro)	(revision 23)
@@ -210,6 +210,11 @@
 		    "Transaction is not active");
 	    }
         }
+
+	public void prepare() throws Exception {
+	    txn.prepare();
+	}
+
         public void commit() throws Exception {
             txn.commit();
         }
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/kernel/TaskHandler.java	(.../branches/decoupled/distro)	(revision 23)
@@ -224,6 +224,7 @@
         try {
 	    try {
 		task.run();
+		handle.prepare();
 	    } finally {
 		// regardless of the outcome, always clear the current state
 		// before aborting or committing
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionHandle.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionHandle.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionHandle.java	(.../branches/decoupled/distro)	(revision 23)
@@ -36,7 +36,13 @@
     Transaction getTransaction();
 
     /**
-     * Prepares and commits the transaction associated with this handle. <p>
+     * Prepares the transaction associated with this handle. {@link #commit()}
+     * must be called after calling this method.
+     */
+    void prepare() throws Exception;
+
+    /**
+     * Commits the transaction associated with this handle. <p>
      *
      * If the transaction has been aborted, or when preparing a transaction
      * participant aborts the transaction without throwing an exception, then
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionImpl.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionImpl.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionImpl.java	(.../branches/decoupled/distro)	(revision 23)
@@ -296,23 +296,9 @@
 
     /* -- Other methods -- */
 
-    /**
-     * Commits this transaction
-     *
-     * @throws	TransactionNotActiveException if the transaction has been
-     *		aborted
-     * @throws	TransactionAbortedException if a call to {@link
-     *		TransactionParticipant#prepare prepare} on a transaction
-     *		participant aborts the transaction but does not throw an
-     *		exception
-     * @throws	IllegalStateException if {@code prepare} has been called on any
-     *		transaction participant and {@link Transaction#abort abort} has
-     *		not been called on the transaction
-     * @throws	Exception any exception thrown when calling {@code prepare} on
-     *		a participant
-     * @see	TransactionHandle#commit TransactionHandle.commit
-     */
-    void commit() throws Exception {
+    private ProfileParticipantDetailImpl detail;
+
+    void prepare() throws Exception {
 	assert Thread.currentThread() == owner : "Wrong thread";
 	logger.log(Level.FINER, "commit {0}", this);
 	if (state == State.ABORTED) {
@@ -324,7 +310,7 @@
 	}
 	state = State.PREPARING;
 	long startTime = 0;
-	ProfileParticipantDetailImpl detail = null;
+	detail = null;
 	for (Iterator<TransactionParticipant> iter = participants.iterator();
 	     iter.hasNext(); )
 	{
@@ -334,38 +320,21 @@
 		startTime = System.currentTimeMillis();
 	    }
 	    try {
-		if (iter.hasNext()) {
-		    boolean readOnly = participant.prepare(this);
-		    if (collector != null) {
-			detail.setPrepared(System.currentTimeMillis() -
-					   startTime, readOnly);
-		    }
-		    if (readOnly) {
-			iter.remove();
-			if (collector != null)
-			    collector.addParticipant(detail);
-		    }
-		    if (logger.isLoggable(Level.FINEST)) {
-			logger.log(Level.FINEST,
-				   "prepare {0} participant:{1} returns {2}",
-				   this, participant, readOnly);
-		    }
-		} else {
-		    participant.prepareAndCommit(this);
-		    if (collector != null) {
-			detail.
-			    setCommittedDirectly(System.currentTimeMillis() -
-						 startTime);
-			collector.addParticipant(detail);
-		    }
+		boolean readOnly = participant.prepare(this);
+		if (collector != null) {
+		    detail.setPrepared(System.currentTimeMillis() -
+			    startTime, readOnly);
+		}
+		if (readOnly) {
 		    iter.remove();
-		    if (logger.isLoggable(Level.FINEST)) {
-			logger.log(
-			    Level.FINEST,
-			    "prepareAndCommit {0} participant:{1} returns",
-			    this, participant);
-		    }
+		    if (collector != null)
+			collector.addParticipant(detail);
 		}
+		if (logger.isLoggable(Level.FINEST)) {
+		    logger.log(Level.FINEST,
+			    "prepare {0} participant:{1} returns {2}",
+			    this, participant, readOnly);
+		}
 	    } catch (Exception e) {
 		if (logger.isLoggable(Level.FINEST)) {
 		    logger.logThrow(
@@ -383,7 +352,30 @@
 		    "Transaction has been aborted", abortCause);
 	    }
 	}
+    }
+
+    /**
+     * Commits this transaction
+     *
+     * @throws	TransactionNotActiveException if the transaction has been
+     *		aborted
+     * @throws	TransactionAbortedException if a call to {@link
+     *		TransactionParticipant#prepare prepare} on a transaction
+     *		participant aborts the transaction but does not throw an
+     *		exception
+     * @throws	IllegalStateException if {@code prepare} has been called on any
+     *		transaction participant and {@link Transaction#abort abort} has
+     *		not been called on the transaction
+     * @throws	Exception any exception thrown when calling {@code prepare} on
+     *		a participant
+     * @see	TransactionHandle#commit TransactionHandle.commit
+     */
+    void commit() throws Exception {
+	if (state != State.PREPARING) {
+	    throw new IllegalStateException("state is " + state);
+	}
 	state = State.COMMITTING;
+	long startTime = 0;
 	for (TransactionParticipant participant : participants) {
 	    if (logger.isLoggable(Level.FINEST)) {
 		logger.log(Level.FINEST, "commit {0} participant:{1}",
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionCoordinatorImpl.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionCoordinatorImpl.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/transaction/TransactionCoordinatorImpl.java	(.../branches/decoupled/distro)	(revision 23)
@@ -95,6 +95,10 @@
 	    return txn;
 	}
 
+	public void prepare() throws Exception {
+	    txn.prepare();
+	}
+
 	public void commit() throws Exception {
 	    txn.commit();
 	}
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/ReferenceTable.java	(.../branches/decoupled/distro)	(revision 23)
@@ -20,10 +20,8 @@
 package com.sun.sgs.impl.service.data;
 
 import com.sun.sgs.app.ManagedObject;
-import java.util.IdentityHashMap;
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.TreeMap;
+
+import java.util.*;
 import java.util.Map.Entry;
 
 /**
@@ -43,6 +41,10 @@
     private final Map<ManagedObject, ManagedReferenceImpl> objects =
 	new IdentityHashMap<ManagedObject, ManagedReferenceImpl>();
 
+    private boolean flushing = false;
+    private final List<ManagedReferenceImpl> flushQueue = new ArrayList<ManagedReferenceImpl>();
+    private final Collection<ManagedObject> unregisterAfterFlush = new ArrayList<ManagedObject>();
+
     /** Creates an instance of this class. */
     ReferenceTable() { }
 
@@ -66,6 +68,9 @@
 
     /** Adds a new managed reference to this table. */
     void add(ManagedReferenceImpl ref) {
+        if (flushing) {
+            flushQueue.add(ref);
+        }
 	assert !oids.containsKey(ref.oid)
 	    : "Found existing reference for oid:" + ref.oid;
 	oids.put(ref.oid, ref);
@@ -96,7 +101,11 @@
      */
     void unregisterObject(ManagedObject object) {
 	assert objects.containsKey(object) : "Object was not found";
-	objects.remove(object);
+        if (flushing) {
+            unregisterAfterFlush.add(object);
+        } else {
+            objects.remove(object);
+        }
     }
 
     /** Removes a managed reference from this table. */
@@ -133,20 +142,46 @@
      * Flushes all references.  Returns information about any objects found to
      * be modified, or null if none were modified.
      */
+    @SuppressWarnings({"ForLoopReplaceableByForEach"})
     FlushInfo flushModifiedObjects() {
-	FlushInfo flushInfo = null;
-	for (ManagedReferenceImpl ref : oids.values()) {
-	    byte[] data = ref.flush();
-	    if (data != null) {
-		if (flushInfo == null) {
-		    flushInfo = new FlushInfo();
-		}
-		flushInfo.add(ref.oid, data);
-	    }
-	}
-	return flushInfo;
+        try {
+            beginFlush();
+            FlushInfo flushInfo = null;
+            // ref.flush() may add more elements to flushQueue, so we must use indexing
+            // instead of foreach (uses Iterator) to avoid ConcurrentModificationException
+            for (int i = 0; i < flushQueue.size(); i++) {
+                ManagedReferenceImpl ref = flushQueue.get(i);
+                byte[] data = ref.flush();
+                if (data != null) {
+                    if (flushInfo == null) {
+                        flushInfo = new FlushInfo();
+                    }
+                    flushInfo.add(ref.oid, data);
+                }
+            }
+            return flushInfo;
+        } finally {
+            endFlush();
+        }
     }
 
+    private void beginFlush() {
+        assert !flushing;
+        assert flushQueue.isEmpty();
+        assert unregisterAfterFlush.isEmpty();
+        flushing = true;
+        flushQueue.addAll(oids.values());
+    }
+
+    private void endFlush() {
+        flushing = false;
+        flushQueue.clear();
+        for (ManagedObject object : unregisterAfterFlush) {
+            unregisterObject(object);
+        }
+        unregisterAfterFlush.clear();
+    }
+
     /**
      * Checks the consistency of this table, throwing an assertion error if a
      * problem is found.
Index: sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java
===================================================================
--- sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java	(.../trunk/distro)	(revision 8)
+++ sgs-src-0.9.5-r3615/src/server/j2se/com/sun/sgs/impl/service/data/SerialUtil.java	(.../branches/decoupled/distro)	(revision 23)
@@ -23,14 +23,11 @@
 import com.sun.sgs.app.ManagedReference;
 import com.sun.sgs.app.ObjectIOException;
 import com.sun.sgs.impl.sharedutil.LoggerWrapper;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamClass;
-import java.io.OutputStream;
+import net.orfjackal.sgs.TransparentReferenceCglibProxyFactory;
+import net.orfjackal.sgs.TransparentReferenceFactory;
+import net.orfjackal.sgs.TransparentReferenceUtil;
+
+import java.io.*;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -291,10 +288,8 @@
 	/** Check for references to managed objects. */
 	protected Object replaceObject(Object object) throws IOException {
 	    if (object != topLevelObject && object instanceof ManagedObject) {
-		throw new ObjectIOException(
-		    "ManagedObject was not referenced through a " +
-		    "ManagedReference: " + safeToString(object),
-		    false);
+                TransparentReferenceFactory factory = TransparentReferenceCglibProxyFactory.INSTANCE;
+                return TransparentReferenceUtil.createTransparentReferenceForSerialization((ManagedObject) object, factory);
 	    } else if (object != null) {
 		Class<?> cl = object.getClass();
 		if (cl.isAnonymousClass()) {
