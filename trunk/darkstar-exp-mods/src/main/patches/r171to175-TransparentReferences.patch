Index: com/sun/sgs/impl/kernel/TransactionSchedulerImpl.java
===================================================================
--- com/sun/sgs/impl/kernel/TransactionSchedulerImpl.java	(revision 161)
+++ com/sun/sgs/impl/kernel/TransactionSchedulerImpl.java	(revision 175)
@@ -21,44 +21,28 @@

 import com.sun.sgs.app.ExceptionRetryStatus;
 import com.sun.sgs.app.TaskRejectedException;
-
 import com.sun.sgs.auth.Identity;
-
 import com.sun.sgs.impl.kernel.schedule.SchedulerQueue;
-
 import com.sun.sgs.impl.service.transaction.TransactionCoordinator;
 import com.sun.sgs.impl.service.transaction.TransactionHandle;
-
 import com.sun.sgs.impl.sharedutil.LoggerWrapper;
-
-import com.sun.sgs.kernel.KernelRunnable;
-import com.sun.sgs.kernel.Priority;
-import com.sun.sgs.kernel.PriorityScheduler;
-import com.sun.sgs.kernel.RecurringTaskHandle;
-import com.sun.sgs.kernel.TaskQueue;
-import com.sun.sgs.kernel.TaskReservation;
-import com.sun.sgs.kernel.TransactionScheduler;
-
+import com.sun.sgs.kernel.*;
 import com.sun.sgs.profile.ProfileCollector;
 import com.sun.sgs.profile.ProfileListener;
 import com.sun.sgs.profile.ProfileReport;
-
 import com.sun.sgs.service.Transaction;
+import net.orfjackal.darkstar.exp.hooks.Hooks;
+import net.orfjackal.darkstar.exp.hooks.hooktypes.BeforeTransactionIsDeactivatedHook;

+import java.beans.PropertyChangeEvent;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-
-import java.beans.PropertyChangeEvent;
-
 import java.util.LinkedList;
 import java.util.Properties;
 import java.util.Queue;
-
-import java.util.concurrent.Executors;
 import java.util.concurrent.ExecutorService;
-
+import java.util.concurrent.Executors;
 import java.util.concurrent.atomic.AtomicInteger;
-
 import java.util.logging.Level;
 import java.util.logging.Logger;

@@ -542,6 +526,7 @@
                     try {
                         // run the task in the new transactional context
                         task.getTask().run();
+                        Hooks.get(BeforeTransactionIsDeactivatedHook.class).beforeTransactionIsDeactivated();
                     } finally {
                         // regardless of the outcome, always clear the current
                         // transaction state before proceeding...
Index: com/sun/sgs/impl/service/data/ReferenceTable.java
===================================================================
--- com/sun/sgs/impl/service/data/ReferenceTable.java	(revision 161)
+++ com/sun/sgs/impl/service/data/ReferenceTable.java	(revision 175)
@@ -20,18 +20,23 @@
 package com.sun.sgs.impl.service.data;

 import com.sun.sgs.app.ManagedObject;
-import java.util.IdentityHashMap;
-import java.util.Map;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.*;
 import java.util.Map.Entry;
-import java.util.SortedMap;
-import java.util.TreeMap;

 /**
  * Stores information about managed references within a particular transaction.
  * This class is logically part of the ManagedReferenceImpl class.
  */
 final class ReferenceTable {
+    private static final Logger logger = LoggerFactory.getLogger(ReferenceTable.class);

+    private enum State {
+        ACTIVE, FLUSHING, CLOSED
+    }
+
     /** Maps object IDs to managed references. */
     private final SortedMap<Long, ManagedReferenceImpl<?>> oids =
 	new TreeMap<Long, ManagedReferenceImpl<?>>();
@@ -43,6 +48,11 @@
     private final Map<ManagedObject, ManagedReferenceImpl<?>> objects =
 	new IdentityHashMap<ManagedObject, ManagedReferenceImpl<?>>();

+    private State state = State.ACTIVE;
+    private final List<ManagedReferenceImpl<?>> flushQueue = new ArrayList<ManagedReferenceImpl<?>>();
+    private final Collection<ManagedObject> unregisterAfterFlush = new ArrayList<ManagedObject>();
+    private FlushInfo flushed;
+
     /** Creates an instance of this class. */
     ReferenceTable() { }

@@ -52,7 +62,7 @@
      */
     ManagedReferenceImpl<?> find(Object object) {
 	assert object != null : "Object is null";
-	return objects.get(object);
+	return objects.get((ManagedObject) object);
     }

     /**
@@ -66,6 +76,10 @@

     /** Adds a new managed reference to this table. */
     void add(ManagedReferenceImpl<?> ref) {
+        assert state != State.CLOSED;
+        if (state == State.FLUSHING) {
+            flushQueue.add(ref);
+        }
 	assert !oids.containsKey(ref.oid)
 	    : "Found existing reference for oid:" + ref.oid;
 	oids.put(ref.oid, ref);
@@ -95,8 +109,12 @@
      * object.
      */
     void unregisterObject(ManagedObject object) {
-	assert objects.containsKey(object) : "Object was not found";
-	objects.remove(object);
+        assert objects.containsKey(object) : "Object was not found";
+        if (state == State.FLUSHING) {
+            unregisterAfterFlush.add(object);
+        } else {
+            objects.remove(object);
+        }
     }

     /** Removes a managed reference from this table. */
@@ -133,20 +151,57 @@
      * Flushes all references.  Returns information about any objects found to
      * be modified, or null if none were modified.
      */
+    @SuppressWarnings({"ForLoopReplaceableByForEach"})
     FlushInfo flushModifiedObjects() {
-	FlushInfo flushInfo = null;
-	for (ManagedReferenceImpl<?> ref : oids.values()) {
-	    byte[] data = ref.flush();
-	    if (data != null) {
-		if (flushInfo == null) {
-		    flushInfo = new FlushInfo();
-		}
-		flushInfo.add(ref.oid, data);
-	    }
-	}
-	return flushInfo;
+        if (state == State.CLOSED) {
+            return flushed;
+        }
+        int sizeBefore = -1;
+        try {
+            beginFlush();
+            sizeBefore = flushQueue.size();
+            FlushInfo flushInfo = null;
+            // ref.flush() may add more elements to flushQueue, so we must use indexing
+            // instead of foreach (uses Iterator) to avoid ConcurrentModificationException
+            for (int i = 0; i < flushQueue.size(); i++) {
+                ManagedReferenceImpl<?> ref = flushQueue.get(i);
+                byte[] data = ref.flush();
+                if (data != null) {
+                    if (flushInfo == null) {
+                        flushInfo = new FlushInfo();
+                    }
+                    flushInfo.add(ref.oid, data);
+                }
+            }
+            flushed = flushInfo;
+            return flushInfo;
+        } catch (RuntimeException e) {
+            logger.warn("Failure in flushing objects, flush queue size is " + flushQueue.size()
+                    + " (" + sizeBefore + " existing and " + (flushQueue.size() - sizeBefore) + " new objects)", e);
+            throw e;
+        } finally {
+            endFlush();
+        }
     }

+    private void beginFlush() {
+        assert state == State.ACTIVE;
+        assert flushQueue.isEmpty();
+        assert unregisterAfterFlush.isEmpty();
+        state = State.FLUSHING;
+        flushQueue.addAll(oids.values());
+    }
+
+    private void endFlush() {
+        assert state == State.FLUSHING;
+        state = State.CLOSED;
+        flushQueue.clear();
+        for (ManagedObject object : unregisterAfterFlush) {
+            unregisterObject(object);
+        }
+        unregisterAfterFlush.clear();
+    }
+
     /**
      * Checks the consistency of this table, throwing an assertion error if a
      * problem is found.
Index: com/sun/sgs/impl/service/data/SerialUtil.java
===================================================================
--- com/sun/sgs/impl/service/data/SerialUtil.java	(revision 161)
+++ com/sun/sgs/impl/service/data/SerialUtil.java	(revision 175)
@@ -24,14 +24,10 @@
 import com.sun.sgs.app.ObjectIOException;
 import com.sun.sgs.impl.sharedutil.LoggerWrapper;
 import com.sun.sgs.impl.sharedutil.Objects;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamClass;
-import java.io.OutputStream;
+import net.orfjackal.darkstar.exp.hooks.Hooks;
+import net.orfjackal.darkstar.exp.hooks.hooktypes.ReplaceObjectOnSerializationHook;
+
+import java.io.*;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -291,7 +287,8 @@

 	/** Check for references to managed objects. */
 	protected Object replaceObject(Object object) throws IOException {
-	    if (object != topLevelObject && object instanceof ManagedObject) {
+            object = Hooks.get(ReplaceObjectOnSerializationHook.class).replaceObject(object, topLevelObject);
+            if (object != topLevelObject && object instanceof ManagedObject) {
 		throw new ObjectIOException(
 		    "ManagedObject was not referenced through a " +
 		    "ManagedReference: " + Objects.safeToString(object),
